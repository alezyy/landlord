<?php
/**
 * Copyright 2007-2010, Cake Development Corporation (http://cakedc.com)
 *
 * Licensed under The MIT License
 * Redistributions of files must retain the above copyright notice.
 *
 * @copyright Copyright 2007-2010, Cake Development Corporation (http://cakedc.com)
 * @license MIT License (http://www.opensource.org/licenses/mit-license.php)
 */

/**
 * Utils Plugin
 *
 * Utils Csv Import Behavior
 *
 * @package utils
 * @subpackage utils.models.behaviors
 */
class CsvImportBehavior extends ModelBehavior {

/**
 * Importable behavior settings
 *
 * @var array
 */
	public $config = array();

/**
 * List of errors generated by the import action
 *
 * @var array
 */
	public $errors = array();

/**
 * List of objects instances or callables to notify from events on this class
 *
 * @var array
 */
	protected $_subscribers = array();

/**
 * Initializes this behavior for the model $Model
 *
 * @param Model $Model
 * @param array $settigs list of settings to be used for this model
 * @return void
 */
	public function setup(model $model, $config = array()) {
		if (!isset($this->config[$model->alias])) {
			$this->config[$model->alias] = array(
				'delimiter' => ';',
				'enclosure' => '"',
				'hasHeader' => true
			);
		}
		$this->config[$model->alias] = array_merge($this->config[$model->alias], $config);
	}

/**
 * Returns a line form the CSV file and advances the pointer to the next one
 *
 * @param Model $Model
 * @param SplFileObject $handle CSV file handler
 * @return array list of attributes fetched from the CSV file
 */
	protected function _getCSVLine(Model $model, SplFileObject $handle) {
		if ($handle->eof()) {
			return false;
		}
		return $handle->fgetcsv(
			$this->config[$model->alias]['delimiter'],
			$this->config[$model->alias]['enclosure']
		);
	}

/**
 * Returns a list of keys representing the columns of the CSV file
 *
 * @param Model $Model
 * @param SplFileObject $handle CSV file handler
 * @return array list of attributes fetched from the CSV file
 */
	protected function _getHeader(Model $model, SplFileObject $handle) {
		if ($this->config[$model->alias]['hasHeader'] === true) {
        	$header = $this->_getCSVLine($model, $handle);
        } else {
        	$header = array_keys($model->schema());
        }
        return $header;
	}

/**
 * Returns a list of keys representing the columns of the CSV file
 *
 * @param Model $Model
 * @param string $file path to the CSV file
 * @param array $fixed data to be merged with every row
 * @param boolean $returnSaved true to return
 * @throws RuntimeException if $file does not exists
 * @return mixed boolean indicating the success of the operation or list of saved records
 */
	public function importCSV(Model $model, $file, $fixed = array(), $returnSaved = false) {
		$handle = new SplFileObject($file, 'rb');
		$header = $this->_getHeader($model, $handle);
		$db = $model->getDataSource();
		$db->begin($model);
		$saved = array();
		$i = 0;
		while (($row = $this->_getCSVLine($model, $handle)) !== false) {
			$data = array();
			foreach ($header as $k => $col) {
				// get the data field from Model.field
				if (strpos($col, '.') !== false) {
					list($model,$field) = explode('.',$col);
					$data[$model][$field]= (isset($row[$k])) ? $row[$k] : '';
				} else {
					$data[$model->alias][$col]= (isset($row[$k])) ? $row[$k] : '';
				}
			}

			$data = Set::merge($data, $fixed);
			$model->create();
			$model->id = isset($data[$model->alias][$model->primaryKey]) ? $data[$model->alias][$model->primaryKey] : false;

			//beforeImport callback
			if (method_exists($model, 'beforeImport')) {
				$data = $model->beforeImport($data);
			}

			$error = false;
			$model->set($data);
			if (!$model->validates()) {
				$this->errors[$model->alias][$i]['validation'] = $model->validationErrors;
				$error = true;
				$this->_notify($model, 'onImportError', $this->errors[$model->alias][$i]);
			}

			// save the row
			if (!$error && !$model->saveAll($data, array('validate' => false,'atomic' => false))) {
				$this->errors[$model->alias][$i]['save'] = sprintf(__d('utils', '%s for Row %d failed to save.'), $model->alias, $i);
				$error = true;
				$this->_notify($model, 'onImportError', $this->errors[$model->alias][$i]);
			}

			if (!$error) {
				$this->_notify($model, 'onImportRow', $data);
				if ($returnSaved) {
					$saved[] = $i;
				}
			}

			$i++;
		}

		$success = empty($this->errors);
		if (!$returnSaved && !$success) {
			$db->rollback($model);
			return false;
		}

		$db->commit($model);

		if ($returnSaved) {
			return $saved;
		}

		return true;
	}

/**
 * Returns the errors generated by last import
 *
 * @param Model $Model
 * @return array
 */
	public function getImportErrors(Model &$model) {
		if (empty($this->errors[$model->alias])) {
			return array();
		}
		return $this->errors[$model->alias];
	}

/**
 * Attachs a new listener for the events generated by this class
 *
 * @param Model $Model
 * @param mixed listener instances of an object or valid php callback
 * @return void
 */
	public function attachImportListener(Model $model, $listener) {
		$this->_subscribers[$model->alias][] = $listener;
	}

/**
 * Notifies the listeners of events generated by this class
 *
 * @param Model $Model
 * @param string $action the name of the event. It will be used as method name for object listeners
 * @param mixed $data additional information to pass to the listener callback
 * @return void
 */
	protected function _notify(Model $model, $action, $data = null) {
		if (empty($this->_subscribers[$model->alias])) {
			return;
		}
		foreach ($this->_subscribers[$model->alias] as $object) {
			if (method_exists($object, $action)) {
				$object->{$action}($data);
			}
			if (is_callable($object)) {
				call_user_func($object, $action, $data);
			}
		}
	}
}
